#!/usr/bin/env python3
"""
Demo: Symbolic Function Discovery

Feed a stream of numbers generated by a mathematical function.
The system discovers the generating function by:
  1. Maintaining a population of candidate function types
  2. Fitting coefficients via least squares / gradient descent
  3. Composing functions via residual analysis
  4. Reporting the discovered formula in symbolic form

The power: instead of opaque weight matrices, the system keeps candidates
for what might be the generating function, composed from known types.
If the guess is right, the model is tiny and perfectly accurate.

Test functions (increasing difficulty):
  1. y = 2x + 3                (linear)
  2. y = 0.5x^2 - 3x + 10     (quadratic)
  3. y = 3sin(0.5x) + 1        (trigonometric)
  4. y = 0.1x^2 + 2sin(x)      (composed: quadratic + trig)
"""

import sys
import os
import numpy as np

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from cognitive_fractal.symbolic_engine import SymbolicEngine


# ============================================================
# TEST FUNCTIONS
# ============================================================

def linear_fn(x):
    return 2.0 * x + 3.0


def quadratic_fn(x):
    return 0.5 * x ** 2 - 3.0 * x + 10.0


def trig_fn(x):
    return 3.0 * np.sin(0.5 * x) + 1.0


def composed_fn(x):
    return 0.1 * x ** 2 + 2.0 * np.sin(x)


SCENARIOS = [
    ("Linear: y = 2x + 3", linear_fn, 200, 0.01),
    ("Quadratic: y = 0.5x^2 - 3x + 10", quadratic_fn, 200, 0.1),
    ("Trig: y = 3sin(0.5x) + 1", trig_fn, 300, 1.0),
    ("Composed: y = 0.1x^2 + 2sin(x)", composed_fn, 400, 2.0),
]


# ============================================================
# RUN ONE SCENARIO
# ============================================================

def run_scenario(name, func, n_steps, error_threshold):
    """Run one function discovery scenario.

    Returns True if the future prediction error is within threshold.
    """
    print(f"\n{'=' * 64}")
    print(f"  SCENARIO: {name}")
    print(f"  Steps: {n_steps}  |  Error threshold: {error_threshold}")
    print(f"{'=' * 64}")

    engine = SymbolicEngine(
        window_size=30,
        predict_horizon=1,
        composition_interval=50,
        composition_threshold=0.3,
        max_candidates=20,
    )

    errors = []
    prev_pred = None

    for t in range(n_steps):
        y = func(float(t))
        pred, diag = engine.step(y)

        # Track prediction error (previous pred vs current actual)
        if prev_pred is not None:
            errors.append(abs(prev_pred - y))
        prev_pred = pred

        # Report at intervals
        if (t + 1) % 50 == 0 and t > 0:
            recent_err = np.mean(errors[-50:]) if len(errors) >= 50 else np.mean(errors)
            print(
                f"  Step {t + 1:4d}: "
                f"avg_error={recent_err:12.6f}  "
                f"best={diag['best_name']:24s}  "
                f"fitness={diag['best_fitness']:.4f}  "
                f"candidates={diag['num_candidates']}"
            )

    # --- Final report ---
    formula, fitness, best = engine.get_best()
    n_future = 5
    future_x = np.arange(n_steps, n_steps + n_future, dtype=float)
    predictions = engine.get_predictions(n_future)
    actuals = np.array([func(float(x)) for x in future_x])
    future_errors = np.abs(predictions - actuals)
    mean_future_error = np.mean(future_errors)

    print()
    print(f"  DISCOVERED FORMULA:  {formula}")
    print(f"  FITNESS:             {fitness:.4f}")
    print(f"  CANDIDATES TRIED:    {len(engine.candidates)}")
    print()
    print(f"  FUTURE PREDICTIONS (next {n_future} values):")
    print(f"  {'x':>6s}  {'Predicted':>14s}  {'Actual':>14s}  {'Error':>12s}")
    print(f"  {'-' * 52}")
    for i in range(n_future):
        print(
            f"  {int(future_x[i]):6d}  "
            f"{predictions[i]:14.4f}  "
            f"{actuals[i]:14.4f}  "
            f"{future_errors[i]:12.6f}"
        )

    print()
    print(f"  MEAN FUTURE ERROR:   {mean_future_error:.6f}")
    passed = mean_future_error < error_threshold
    print(f"  STATUS:              {'PASS' if passed else 'FAIL'}")

    # --- Show all candidate fitnesses ---
    stats = engine.get_stats()
    print()
    print(f"  ALL CANDIDATES (ranked by fitness):")
    for i, cd in enumerate(stats["candidate_details"][:8]):
        marker = " <-- BEST" if i == 0 else ""
        print(
            f"    {cd['name']:28s}  "
            f"fitness={cd['fitness']:.4f}  "
            f"{cd['formula'][:50]}{marker}"
        )
    if len(stats["candidate_details"]) > 8:
        print(f"    ... and {len(stats['candidate_details']) - 8} more")

    return passed


# ============================================================
# MAIN
# ============================================================

def main():
    print("=" * 64)
    print("  SYMBOLIC FUNCTION DISCOVERY")
    print("  Built on Cognitive Fractal Infrastructure")
    print("=" * 64)
    print()
    print("  The system keeps candidates for what might be the generating")
    print("  function, using compositions of known mathematical types.")
    print("  Coefficients are learned via least squares / gradient descent.")
    print()
    print("  Four Pillars in Action:")
    print("    Feedback Loops:  predict -> observe -> correct (every step)")
    print("    Approximability: coefficients converge with more data")
    print("    Composability:   residual analysis decomposes y = f(x) + g(x)")
    print("    Exploration:     population of candidates explores function space")

    results = []
    for name, func, n_steps, threshold in SCENARIOS:
        passed = run_scenario(name, func, n_steps, threshold)
        results.append((name, passed))

    # --- Final summary ---
    print()
    print("=" * 64)
    print("  SUMMARY")
    print("=" * 64)
    for name, passed in results:
        status = "PASS" if passed else "FAIL"
        print(f"  [{status}] {name}")

    all_passed = all(p for _, p in results)
    print()
    if all_passed:
        print("  SUCCESS: All scenarios discovered their generating functions.")
    else:
        print("  PARTIAL: Some scenarios did not meet accuracy thresholds.")
        sys.exit(1)


if __name__ == "__main__":
    main()
